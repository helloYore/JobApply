# JAVA 虚拟机 总结

## 1. 概述

​		Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。 特点：

​		一次编译，到处运行。

​		自动内存管理

​		自动垃圾回收功能

## 2. Java 内存区域与内存溢出异常

### 运行时数据区域

![Java虚拟机运行时数据区](C:\Users\wang_\Pictures\编程\Java相关\Java虚拟机运行时数据区.png)

​		![image-20210524162551938](C:\Users\wang_\Pictures\编程\Java相关\Java虚拟机运行时数据区1.png)	**口述**：Java虚拟机管理的内存中 主要包括 线程共享的方法区和堆，线程隔离的虚拟机栈，本地方法栈，程序计数器。再分别进行介绍。

  #### 方法区（Method Area） 

​		是各个线程共享的内存区域，用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。虚拟机规范中将其描述为堆的一个逻辑部分，但是他别名叫做Non-Heap（非堆），与Java堆区分出来。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

#### 运行时常量池（Runtime Constant Pool）

​		方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。也受到方法区内存的限制，如果无法再申请到内存时，会抛出OutOfMemoryError异常

#### Java堆（Heap）

​		唯一目的就是为了存放对象实例，几乎所有对象实例都在这里分配内存，堆是垃圾收集器管理的主要区域。 Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。

​		从内存回收的角度来看，由于现在收集器基本采用分带手机算法，所以可以再细分为：新生代，老年代。 再细分可以分为 Eden空间，From Survivor空间，To Survivor空间等。

​		 划分的目的主要是更快地回收内存。

​		如果堆中没有内存完成实力分配，而且堆也无法再进行扩展时，将会抛出OutOfMemoryError异常

#### 虚拟机栈(Java Virtual Machine Stacks)

  + 线程私有的， 生命周期与线程相同
  + 描述的是Java方法执行的内存模型：每个方法在执行的同时就会创建一个栈帧（Stack Frame）用于存储局部变量表，操作数栈，动态链接等信息。每一个方法从调用到执行完成的过程，就对应了一个栈帧在虚拟机栈中从入栈到出栈的过程。
  + 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常

#### 本地方法栈（Native Method Stack）

	+ 与虚拟机栈作用相似，区别在于：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。
	+ 有些虚拟机甚至把两者合为一体（Sun HotSpot虚拟机） 
 + 抛出异常同 虚拟机栈

#### 程序计数器

+ 一块比较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。
+ Java虚拟机的多线程是通过线程轮流切换并且分配处理器执行时间的方式来实现的，在一个任何确定的时刻，一个处理器（对于多  核处理器来说是一个内核）都只会执行一条线程中的指令。 
+ 每个线程都有一个独立的程序计数器，互不影响。
+ 如果线程执行的是一个Java方法， 记录**正在执行的虚拟机字节码指令的地址**
+ 如果线程执行的是一个Native方法，则值为**空**
+ **此内存区是唯一一个没有规定任何OutOfMemoryError情况的区域**

## 3. JVM与Java体系结构

### Java编译器  基于栈式架构 且与寄存器架构对比  		![image-20210524143423152](C:\Users\wang_\Pictures\编程\Java相关\前端编译过程1.png)

​		早期的虚拟机只有解释器，没有JIT编译器，也可以，（解释器响应时间很快）但是效率很低。

​		JIT编译器把反复执行的热点代码编译成为本地机器指令，然后放在方法区里缓存起来（方法区的CodeCache），便于调用。

​		Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。

![image-20210524150514509](C:\Users\wang_\Pictures\编程\Java相关\基于栈的指令集架构.png)

​	 	![image-20210524150622244](C:\Users\wang_\Pictures\编程\Java相关\基于栈的指令集架构2.png)![image-20210524150603927](C:\Users\wang_\Pictures\编程\Java相关\基于栈的指令集架构1.png)







![image-20210524150751760](C:\Users\wang_\Pictures\编程\Java相关\基于寄存器的指令集架构.png)

![image-20210524150833322](C:\Users\wang_\Pictures\编程\Java相关\基于寄存器的指令集架构1.png)

栈：跨平台性，指令集小，指令多；执行性能比寄存器差

### JVM生命周期

​		执行一个所谓的Java程序的时候，真正执行的是一个叫做Java虚拟机的进程。	

​		虚拟机的退出：

	1.程序正常结束执行
	2.异常或者错误终止
	3.OS操作导致进程终止
	4.调用Runtime类或者System类的exit方法或者Runtime的halt方法，且Java安全管理器也允许此次exit或halt操作
	5.JNI（Java Native Interface）用JNI Invocation API来加载或者卸载Java虚拟机时退出

### JVM的虚拟机发展史

classic VM（解释器） =》Exact VM(编译器 解释器混合 ，热点探测) =》HotSpot VM（默认虚拟机）  

JRockit（专注于服务器端应用，最快的JVM，不太关注程序启动速度，内部不包含解析器实现，全部代码靠即时编译器编译后执行）

J9（IBM，在IBM硬件上速度快）

Azual VM （基于HotSpot改进，与特定硬件平台绑定，软硬件配合的专用虚拟机）

TaobaoVM....

Graal VM(HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为任何语言的运行平台使用)  将语言的源代码或者源代码编译后的中间格式，通过解释器转换成能被Graal VM接受的中间表示， 运行时还能进行即时编译优化。

## 4. 类加载子系统

![image-20210524162702824](C:\Users\wang_\Pictures\编程\Java相关\Java虚拟机运行时数据区详细En.png)

![image-20210524162758697](C:\Users\wang_\Pictures\编程\Java相关\Java虚拟机运行时数据区详细CH.png)

### 类加载过程

​		ClassLoader 只负责class文件的加载，至于是否能够运行，则由Execution Engine决定。 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还存放运行时常量池信息。![image-20210524163825539](C:\Users\wang_\Pictures\编程\Java相关\类的加载过程.png)

类加载的三个过程：![image-20210524211029351](C:\Users\wang_\Pictures\编程\Java相关\类的加载过程2.png)

 + 加载loader：获取此类的二进制字节流，将其静态存储结构转化为方法区的运行时数据结构，在内存中**生成一个代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口。

 + 链接linking（验证Verify 准备Prepare 解析Resolve）

    + 注意：**准备阶段不包含用final修饰的static**，因为final在编译的时候就会分配了，准备阶段会显式初始化。
    +  这里**不会为实例变量分配初始化**，类变量会分配在方法区中，**实例变量会随着对象一起分配到Java堆中**。
    + 解析：将常量池内的符号引用转换为直接引用的过程

 + 初始化 initial

    + 初始化阶段就是执行类 构造器方法<clinit>()的过程

      这个方法不需要定义，是由javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 顺序执行。

    + <clinit>()方法不同于类的构造器

    + 虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。

    + ![image-20210524172033719](C:\Users\wang_\Pictures\编程\Java相关\类的加载过程1.png)

      这里 因为链接中的prepare阶段已经将number赋值为0了，相当于变量已经被加载到内存中，做了默认初始化。然后在initialization环节中进行重新的覆盖，覆盖顺序 按照编码顺序，先是20，然后是10，所以最后结果是10.

### 类加载器分类

* JVM支持两种类型类加载器 **引导类加载器（Bootstrap ClassLoader）** 和**自定义类加载器（User-Defined ClassLoader）**
* 所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。

  + #### **虚拟机自带的加载器**
    
      +  **启动类加载器（引导类加载器，Bootstrap ClassLoader）**
          + 类加载使用C/C++语言实现
          + Java的核心类库都是使用引导类加载器进行加载的。 
          + **不继承于java.lang.ClassLoader**，没有父加载器，其余所有的类加载器都继承于ClassLoader
          + 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
          + 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类。
        + 获取不到
    + **扩展类加载器（Extension ClassLoader）**
      + Java语言编写
      + 派生于ClassLoader类
      + 父类加载器为启动类加载器
    + **应用程序类加载器（系统类加载器，AppClassLoader）**
      + Java语言编写、
      + 派生于ClassLoader类
      + 属于** **，一般来说，Java应用的类都是由他加载完成
      + 通过ClassLoader#getSystemClassLoader()方法获取
+ #### **用户自定义类加载器**
  
  + 用处：
    + 隔离加载类
    + 修改类加载的方式
    + 扩展加载源
    + 防止源码泄露
  + 实现步骤：
    + 通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器
    + **JDK1.2之后不建议覆盖loadClass方法， 而是建议把自定义的类加载逻辑写在findClass()方法中**
    + 如果没有过于复杂的需求，可以直接继承URLClassLoader类，避免自己写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。 
+ 几种不同的方式来获取加载器
  
  + ![image-20210524232119134](C:\Users\wang_\Pictures\编程\Java相关\类加载器.png)

###  双亲委派机制

![image-20210525095158246](C:\Users\wang_\Pictures\编程\Java相关\双亲委派机制.png)

+ 类加载器的双亲委派模型机制， 要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 这里类加载器的父子关系不以继承（Inheritance）的关系来体现，而是都使用组合关系（Composition）来复用父加载器的代码   

+ 非强制的约束模型 是Java设计者推荐的一种类加载实现方式

#### 工作过程

+ 一个类加载器收到了类加载的请求，首先它会把这个请求委派给父类加载器去完成
+ 每一个层次的类加载器都是如此，逐级反馈

  +  所有的加载请求最终都应该传送到顶层的启动类加载器中
  +  只有当父加载器反馈自己无法完成这个加载请求（他的搜索范围内没有找到所需的类时），子加载器才会尝试自己去加载。

#### 好处

+ Java类随着它的类加载器一起具备了一种带有优先级的层次关系。
+ 例如类java.lang.Object 位于rt.jar中，无论哪个类加载器要加载这个类，都会委派给模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。 
+ 否则，如果用户也写了一个java.lang.Object类，并放在程序的ClassPath中，系统中会有多个不同的Object类，就会变得一片混乱。
+ 所以rt.jar类库中已有类重名的类可以编译，但是无法加载执行。
+ 保证Java程序的稳定运行。（也有叫作**沙箱安全机制**）

#### 代码实现

+ 代码集中在java.lang.ClassLoader的loadClass()方法中。
+ 首先检查是否已经被加载过，如果没有加载则调用父加载器的loadClass()方法，
+ 若父加载器为空则默认使用启动类加载器作为父加载器。
+ 如果父类加载失败，抛出ClassNotFoundException异常后，
+ 再调用自己的findClass()方法进行加载。

#### 破坏双亲委派模型

![image-20210525100342481](C:\Users\wang_\Pictures\编程\Java相关\双亲委派机制1.png)

+ 程序中需要用到SPI接口， SPI接口属于核心API，则根据双亲委派机制，依次到引导类加载器，加载rt.jar包，则rt.jar包中的SPI核心类就加载过来了。

+ 这里面存在一些interface接口，需要用到具体的实现类，具体的实现类就涉及到了一些第三方的jar包，我们要加载的是jdbc.jar包，因为不属于核心API，则应该由线程上下文加载器（系统类加载器）来进行加载。（反向委派，一直委托到系统类加载器），

+ 是由我们当前线程的上下文加载器通过getContextClassLoader获取到的，由他来加载SPI接口的具体实现类。（也就是jdbc.jar包里面的API）

## 5. 运行时数据区



 

